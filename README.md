# reverse

This is a simple CLI tool for checking that arbitrarily-defined locations in code are kept
up-to-date. It uses user-defined regex matching to determine names and versions and produces errors
if any "usage locations" don't match the version in the original definition.

I originally made this tool for work on my [text editor](https://github.com/sharnoff/viri), but
you're welcome to use it as well. I'm open to suggestions for improvements :)

I'm not sure what the motivation behind the name was originally -- probably something to do with
'REfined VERSion tracking', but I'll never be certain.

## Set-up and usage

Install using cargo:

```sh
cargo install --git "https://github.com/sharnoff/reverse"
```

`reverse` reads from a file in your repository, typically 'reverse.toml'. In this file, a few key
things are defined:

* The regex pattern for "definitions"
  * And the relevant groups within that regex
* The regex pattern for "requirements" (i.e. usages)
  * And the relevant gropus for these as well

There are other fields too, but those are optional.

What `reverse` will do is scan your repository for occurences of these "definitions" and
"requirements" and check that each requirement location matches the version of the definition. If
there's no definition for a requirement, that's also an error.

Here's what a typical 'reverse.toml' file might look like:

```toml
def_match         = '''@def\s*("[^"]*")\s*(v[\d\.]+)'''
def_name_group    = 1
def_version_group = 2
req_match         = '''@req\s*("[^"]*")\s*(v[\d\.]+)'''
req_name_group    = 1
req_version_group = 2
warn_match        = '''@(req|def)'''
exclude           = [".git", "reverse.toml", "target"]
```

(This is actually what's generated by `reverse init --lang=rust`.)

The config file here expects definitions of the form '@def "name" v&lt;N&gt;' and requirements to be
similar, but with '@req' instead.

The 'warn_match' field indicates that if we find either '@req' or '@def' and it *wasn't* a match,
that was probably a mistake and so we should emit a warning. The 'exclude' field gives a few paths
to exclude from checking -- I'd recommend a similar scheme.

When given this code with that 'reverse.toml':

```rust
/// Returns "yay!" or "nope", depending on whether the universe is kind
//
// Our documentation here relies on the functioning of `fallback`. In
// order to prevent someone from changing 'fallback' without updating
// this documentation, we add a requirement:
//
//   @req "fallback return value" v0
//
// Up in the documentation of this function, we're expecting the
// return to be "nope".
pub fn kindness_detector() -> &'static str {
    if the_universe_is_kind() {
        return "yay!";
    }

    return fallback();
}

// For the purposes of this demonstration, we've changed the output so
// that it doesn't match what we're expecting above.
//
// We've also changed the *version* of the definition, which means
// that 'reverse' correctly produces an error to identify the
// mismatch - reminding us to update the docs.
fn fallback() -> &'static str {
    // @def "fallback return value" v1
    "maybe, who knows"
}
```

... it'll output:

```
"fallback return value" -> 0/1
[error] Version mismatch for '"fallback return value"'; expected 'v1', found 'v0'
  --> readme-example.rs:7:5
   |
7  | //   @req "fallback return value" v0
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: the definition for '"fallback return value"' is given here:
  --> readme-example.rs:26:7
   |
26 |     // @def "fallback return value" v1
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```

## Contributing

Feel free to open issues & PRs! I'll respond to them as soon as I can (typically within a few days).

I'm particularly looking for exclude patterns for other languages; those should be very simple to
add.
